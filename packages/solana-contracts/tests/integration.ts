/**
 * Integration tests for IZI-NOIR Solana Groth16 Verifier
 *
 * These tests verify that the on-chain program can:
 * 1. Initialize a VK account from arkworks gnark-compatible bytes
 * 2. Verify Groth16 proofs generated by arkworks-groth16-wasm
 *
 * Test vectors are loaded from test-vectors.json, which is generated by:
 *   npm run generate-vectors
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";
import { readFileSync, existsSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

// Import generated types
import type { IziNoir as IziNoirProgram } from "../target/types/izi_noir";

const __dirname = dirname(fileURLToPath(import.meta.url));

// Constants matching the program
const G1_SIZE = 64;
const G2_SIZE = 128;

// Helper functions
function base64ToBytes(b64: string): Uint8Array {
  return Uint8Array.from(Buffer.from(b64, "base64"));
}

function hexToBytes32(hex: string): number[] {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const paddedHex = cleanHex.padStart(64, "0");
  const bytes: number[] = [];
  for (let i = 0; i < 64; i += 2) {
    bytes.push(parseInt(paddedHex.substring(i, i + 2), 16));
  }
  return bytes;
}

function parseVkFromBytes(vkBytes: Uint8Array, nrPubinputs: number) {
  let offset = 0;

  const alphaG1 = Array.from(vkBytes.slice(offset, offset + G1_SIZE));
  offset += G1_SIZE;

  const betaG2 = Array.from(vkBytes.slice(offset, offset + G2_SIZE));
  offset += G2_SIZE;

  const gammaG2 = Array.from(vkBytes.slice(offset, offset + G2_SIZE));
  offset += G2_SIZE;

  const deltaG2 = Array.from(vkBytes.slice(offset, offset + G2_SIZE));
  offset += G2_SIZE;

  const k: number[][] = [];
  for (let i = 0; i <= nrPubinputs; i++) {
    k.push(Array.from(vkBytes.slice(offset, offset + G1_SIZE)));
    offset += G1_SIZE;
  }

  return { alphaG1, betaG2, gammaG2, deltaG2, k };
}

// Load test vectors from JSON file
interface TestVectorsJson {
  generatedAt: string;
  circuit: string;
  inputs: { expected: string; secret: string };
  nrPubinputs: number;
  vkBase64: string;
  proofBase64: string;
  publicInputsHex: string[];
  accountSize: number;
  estimatedRent: number;
}

function loadTestVectors(): {
  vkBytes: Uint8Array;
  proofBytes: Uint8Array;
  publicInputBytes: Uint8Array[];
  nrPubinputs: number;
} | null {
  const vectorsPath = join(__dirname, "test-vectors.json");

  if (!existsSync(vectorsPath)) {
    console.log("âš ï¸  test-vectors.json not found.");
    console.log("   Run: npm run generate-vectors");
    return null;
  }

  const json = JSON.parse(readFileSync(vectorsPath, "utf-8")) as TestVectorsJson;

  console.log(`ðŸ“‹ Loaded test vectors from ${vectorsPath}`);
  console.log(`   Generated: ${json.generatedAt}`);
  console.log(`   Circuit: ${json.inputs.expected} == ${json.inputs.secret}^2`);

  return {
    vkBytes: base64ToBytes(json.vkBase64),
    proofBytes: base64ToBytes(json.proofBase64),
    publicInputBytes: json.publicInputsHex.map((hex) => Uint8Array.from(hexToBytes32(hex))),
    nrPubinputs: json.nrPubinputs,
  };
}

describe("izi-noir integration tests", () => {
  // Configure the client to use devnet
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.IziNoir as Program<IziNoirProgram>;

  // Test vectors loaded from file
  let testVectors: ReturnType<typeof loadTestVectors>;

  before(function () {
    testVectors = loadTestVectors();
    if (!testVectors) {
      console.log("\nâš ï¸  Tests will be skipped. Generate test vectors first:");
      console.log("   cd packages/solana-contracts && npm run generate-vectors\n");
    }
  });

  describe("VK Account Initialization", () => {
    it("should initialize VK account from bytes", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      const vkAccount = Keypair.generate();

      console.log(`VK bytes length: ${testVectors.vkBytes.length}`);
      console.log(
        `Expected length: ${G1_SIZE + G2_SIZE * 3 + G1_SIZE * (testVectors.nrPubinputs + 1)}`
      );

      const tx = await program.methods
        .initVkFromBytes(testVectors.nrPubinputs, Buffer.from(testVectors.vkBytes))
        .accounts({
          vkAccount: vkAccount.publicKey,
          authority: provider.wallet.publicKey,
          payer: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vkAccount])
        .rpc();

      console.log(`âœ… VK Account initialized: ${vkAccount.publicKey.toBase58()}`);
      console.log(`   Transaction: ${tx}`);

      // Fetch and verify the account
      const account = await program.account.verifyingKeyAccount.fetch(vkAccount.publicKey);
      expect(account.nrPubinputs).to.equal(testVectors.nrPubinputs);
      expect(account.authority.toBase58()).to.equal(provider.wallet.publicKey.toBase58());
    });

    it("should initialize VK account with separate fields", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      const vkAccount = Keypair.generate();
      const { alphaG1, betaG2, gammaG2, deltaG2, k } = parseVkFromBytes(
        testVectors.vkBytes,
        testVectors.nrPubinputs
      );

      const tx = await program.methods
        .initVk(
          testVectors.nrPubinputs,
          alphaG1 as any,
          betaG2 as any,
          gammaG2 as any,
          deltaG2 as any,
          k as any
        )
        .accounts({
          vkAccount: vkAccount.publicKey,
          authority: provider.wallet.publicKey,
          payer: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vkAccount])
        .rpc();

      console.log(`âœ… VK Account initialized (separate fields): ${vkAccount.publicKey.toBase58()}`);
      console.log(`   Transaction: ${tx}`);

      const account = await program.account.verifyingKeyAccount.fetch(vkAccount.publicKey);
      expect(account.nrPubinputs).to.equal(testVectors.nrPubinputs);
    });
  });

  describe("Proof Verification", () => {
    let vkAccount: Keypair;

    beforeEach(async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      // Initialize a fresh VK account for each test
      vkAccount = Keypair.generate();

      await program.methods
        .initVkFromBytes(testVectors.nrPubinputs, Buffer.from(testVectors.vkBytes))
        .accounts({
          vkAccount: vkAccount.publicKey,
          authority: provider.wallet.publicKey,
          payer: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vkAccount])
        .rpc();
    });

    it("should verify a valid proof", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      const publicInputs = testVectors.publicInputBytes.map((b) => Array.from(b));

      console.log(`Proof bytes length: ${testVectors.proofBytes.length}`);
      console.log(`Public inputs count: ${publicInputs.length}`);

      const tx = await program.methods
        .verifyProof(Buffer.from(testVectors.proofBytes), publicInputs as any)
        .accounts({
          vkAccount: vkAccount.publicKey,
        })
        .rpc();

      console.log(`âœ… Proof verified successfully!`);
      console.log(`   Transaction: ${tx}`);
    });

    it("should reject an invalid proof", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      // Create an invalid proof (all zeros)
      const invalidProof = new Uint8Array(256).fill(0);
      const publicInputs = testVectors.publicInputBytes.map((b) => Array.from(b));

      try {
        await program.methods
          .verifyProof(Buffer.from(invalidProof), publicInputs as any)
          .accounts({
            vkAccount: vkAccount.publicKey,
          })
          .rpc();

        expect.fail("Should have thrown an error for invalid proof");
      } catch (err: any) {
        console.log(`âœ… Invalid proof correctly rejected`);
        expect(err.toString()).to.include("Error");
      }
    });

    it("should reject proof with wrong public input", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      // Wrong input: 99 instead of 100
      const wrongInput = hexToBytes32(
        "0x0000000000000000000000000000000000000000000000000000000000000063"
      );

      try {
        await program.methods
          .verifyProof(Buffer.from(testVectors.proofBytes), [wrongInput as any])
          .accounts({
            vkAccount: vkAccount.publicKey,
          })
          .rpc();

        expect.fail("Should have thrown an error for wrong public input");
      } catch (err: any) {
        console.log(`âœ… Wrong public input correctly rejected`);
        expect(err.toString()).to.include("Error");
      }
    });
  });

  describe("VK Account Management", () => {
    it("should close VK account and return rent", async function () {
      if (!testVectors) {
        this.skip();
        return;
      }

      const vkAccount = Keypair.generate();

      // Initialize
      await program.methods
        .initVkFromBytes(testVectors.nrPubinputs, Buffer.from(testVectors.vkBytes))
        .accounts({
          vkAccount: vkAccount.publicKey,
          authority: provider.wallet.publicKey,
          payer: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([vkAccount])
        .rpc();

      const balanceBefore = await provider.connection.getBalance(provider.wallet.publicKey);

      // Close
      await program.methods
        .closeVk()
        .accounts({
          vkAccount: vkAccount.publicKey,
          authority: provider.wallet.publicKey,
        })
        .rpc();

      const balanceAfter = await provider.connection.getBalance(provider.wallet.publicKey);

      console.log(`âœ… VK Account closed, rent returned`);
      console.log(`   Rent returned: ${(balanceAfter - balanceBefore) / 1e9} SOL`);

      // Verify account is closed
      try {
        await program.account.verifyingKeyAccount.fetch(vkAccount.publicKey);
        expect.fail("Account should be closed");
      } catch (err: any) {
        expect(err.toString()).to.include("Account does not exist");
      }
    });
  });
});
