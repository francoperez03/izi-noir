//! IZI-NOIR Groth16 Verifier Program
//!
//! A generic Solana program for verifying Groth16 zero-knowledge proofs on the BN254 curve.
//! This program can verify proofs from any circuit without recompilation, by receiving
//! the Verification Key (VK) as account data.
//!
//! ## Architecture
//!
//! The program uses a two-step approach:
//! 1. **Initialize VK**: Create an account containing the circuit's verifying key
//! 2. **Verify Proof**: Verify proofs using the stored VK
//!
//! ## Compatibility
//!
//! The VK and proof format is compatible with:
//! - arkworks-groth16-wasm's gnark_compat module
//! - Proofs generated by Arkworks for BN254/Groth16
//!
//! ## Usage Example
//!
//! ```ignore
//! // 1. Initialize a VK account for your circuit
//! let vk_account = init_vk(vk_data);
//!
//! // 2. Verify proofs using the VK
//! verify_proof(vk_account, proof, public_inputs);
//! ```

use anchor_lang::prelude::*;

pub mod error;
pub mod state;
pub mod verifier;

use error::VerifierError;
use state::{
    vk_account_size, Groth16Proof, VerifyingKeyAccount, FIELD_SIZE, G1_SIZE, G2_SIZE,
    MAX_PUBLIC_INPUTS,
};
use verifier::verify_groth16;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod izi_noir {
    use super::*;

    /// Initializes a new verifying key account.
    ///
    /// This instruction creates a new account containing the circuit's verifying key.
    /// The VK is stored in the format compatible with arkworks gnark_compat.
    ///
    /// # Arguments
    ///
    /// * `nr_pubinputs` - Number of public inputs for the circuit
    /// * `alpha_g1` - α element in G1 (64 bytes)
    /// * `beta_g2` - β element in G2 (128 bytes)
    /// * `gamma_g2` - γ element in G2 (128 bytes)
    /// * `delta_g2` - δ element in G2 (128 bytes)
    /// * `k` - Linear combination keys, (nr_pubinputs + 1) G1 points
    ///
    /// # Accounts
    ///
    /// * `vk_account` - The account to initialize (writable, signer for PDA seed)
    /// * `authority` - The authority that can update/close this VK (signer)
    /// * `payer` - Pays for account creation (signer)
    /// * `system_program` - System program for account creation
    pub fn init_vk(
        ctx: Context<InitVk>,
        nr_pubinputs: u8,
        alpha_g1: [u8; G1_SIZE],
        beta_g2: [u8; G2_SIZE],
        gamma_g2: [u8; G2_SIZE],
        delta_g2: [u8; G2_SIZE],
        k: Vec<[u8; G1_SIZE]>,
    ) -> Result<()> {
        // Validate inputs
        require!(
            (nr_pubinputs as usize) <= MAX_PUBLIC_INPUTS,
            VerifierError::TooManyPublicInputs
        );
        require!(
            k.len() == (nr_pubinputs as usize) + 1,
            VerifierError::InvalidVerifyingKey
        );

        let vk_account = &mut ctx.accounts.vk_account;
        vk_account.authority = ctx.accounts.authority.key();
        vk_account.nr_pubinputs = nr_pubinputs;
        vk_account.alpha_g1 = alpha_g1;
        vk_account.beta_g2 = beta_g2;
        vk_account.gamma_g2 = gamma_g2;
        vk_account.delta_g2 = delta_g2;
        vk_account.k = k;

        msg!("Initialized VK account with {} public inputs", nr_pubinputs);
        Ok(())
    }

    /// Initializes a verifying key account from raw bytes.
    ///
    /// This is a convenience instruction that accepts the VK as a contiguous byte array
    /// in the format produced by arkworks gnark_compat's `verifying_key_to_gnark`.
    ///
    /// # Format
    ///
    /// ```text
    /// | alpha_g1 (64) | beta_g2 (128) | gamma_g2 (128) | delta_g2 (128) | k[0..n+1] (64 each) |
    /// ```
    ///
    /// # Arguments
    ///
    /// * `nr_pubinputs` - Number of public inputs for the circuit
    /// * `vk_bytes` - Raw verifying key bytes
    pub fn init_vk_from_bytes(
        ctx: Context<InitVk>,
        nr_pubinputs: u8,
        vk_bytes: Vec<u8>,
    ) -> Result<()> {
        // Validate inputs
        require!(
            (nr_pubinputs as usize) <= MAX_PUBLIC_INPUTS,
            VerifierError::TooManyPublicInputs
        );

        let expected_len = G1_SIZE + G2_SIZE * 3 + G1_SIZE * (nr_pubinputs as usize + 1);
        require!(
            vk_bytes.len() == expected_len,
            VerifierError::InvalidVerifyingKey
        );

        let vk_account = &mut ctx.accounts.vk_account;
        vk_account.authority = ctx.accounts.authority.key();
        vk_account.nr_pubinputs = nr_pubinputs;

        let mut offset = 0;

        // Alpha G1
        vk_account.alpha_g1.copy_from_slice(&vk_bytes[offset..offset + G1_SIZE]);
        offset += G1_SIZE;

        // Beta G2
        vk_account.beta_g2.copy_from_slice(&vk_bytes[offset..offset + G2_SIZE]);
        offset += G2_SIZE;

        // Gamma G2
        vk_account.gamma_g2.copy_from_slice(&vk_bytes[offset..offset + G2_SIZE]);
        offset += G2_SIZE;

        // Delta G2
        vk_account.delta_g2.copy_from_slice(&vk_bytes[offset..offset + G2_SIZE]);
        offset += G2_SIZE;

        // K elements
        let num_k = nr_pubinputs as usize + 1;
        let mut k = Vec::with_capacity(num_k);
        for _ in 0..num_k {
            let mut point = [0u8; G1_SIZE];
            point.copy_from_slice(&vk_bytes[offset..offset + G1_SIZE]);
            k.push(point);
            offset += G1_SIZE;
        }
        vk_account.k = k;

        msg!("Initialized VK account from bytes with {} public inputs", nr_pubinputs);
        Ok(())
    }

    /// Verifies a Groth16 proof against the stored verifying key.
    ///
    /// # Arguments
    ///
    /// * `proof_bytes` - The 256-byte Groth16 proof (A || B || C)
    /// * `public_inputs` - Public inputs as 32-byte big-endian field elements
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if verification succeeds, otherwise returns an error.
    ///
    /// # Accounts
    ///
    /// * `vk_account` - The verifying key account (read-only)
    pub fn verify_proof(
        ctx: Context<VerifyProof>,
        proof_bytes: Vec<u8>,
        public_inputs: Vec<[u8; FIELD_SIZE]>,
    ) -> Result<()> {
        let vk = &ctx.accounts.vk_account;

        // Parse proof
        let proof = Groth16Proof::from_bytes(&proof_bytes)
            .ok_or(VerifierError::InvalidProofSize)?;

        // Validate public inputs count
        require!(
            public_inputs.len() == vk.nr_pubinputs as usize,
            VerifierError::InvalidPublicInputsCount
        );

        // Verify the proof
        verify_groth16(vk, &proof, &public_inputs)?;

        msg!("Proof verified successfully");
        Ok(())
    }

    /// Verifies a Groth16 proof with a structured proof argument.
    ///
    /// This variant accepts the proof as a structured `Groth16Proof` instead of raw bytes.
    pub fn verify_proof_structured(
        ctx: Context<VerifyProof>,
        proof: Groth16Proof,
        public_inputs: Vec<[u8; FIELD_SIZE]>,
    ) -> Result<()> {
        let vk = &ctx.accounts.vk_account;

        // Validate public inputs count
        require!(
            public_inputs.len() == vk.nr_pubinputs as usize,
            VerifierError::InvalidPublicInputsCount
        );

        // Verify the proof
        verify_groth16(vk, &proof, &public_inputs)?;

        msg!("Proof verified successfully");
        Ok(())
    }

    /// Closes a verifying key account and returns rent to the authority.
    ///
    /// Only the authority can close the account.
    pub fn close_vk(_ctx: Context<CloseVk>) -> Result<()> {
        msg!("VK account closed");
        Ok(())
    }
}

/// Accounts for the `init_vk` and `init_vk_from_bytes` instructions.
#[derive(Accounts)]
#[instruction(nr_pubinputs: u8)]
pub struct InitVk<'info> {
    #[account(
        init,
        payer = payer,
        space = vk_account_size(nr_pubinputs as usize),
    )]
    pub vk_account: Account<'info, VerifyingKeyAccount>,

    /// The authority that can update/close this VK.
    pub authority: Signer<'info>,

    /// Pays for account creation.
    #[account(mut)]
    pub payer: Signer<'info>,

    pub system_program: Program<'info, System>,
}

/// Accounts for the `verify_proof` instruction.
#[derive(Accounts)]
pub struct VerifyProof<'info> {
    /// The verifying key account containing circuit parameters.
    pub vk_account: Account<'info, VerifyingKeyAccount>,
}

/// Accounts for the `close_vk` instruction.
#[derive(Accounts)]
pub struct CloseVk<'info> {
    #[account(
        mut,
        close = authority,
        has_one = authority,
    )]
    pub vk_account: Account<'info, VerifyingKeyAccount>,

    /// Must match the authority stored in the VK account.
    #[account(mut)]
    pub authority: Signer<'info>,
}
