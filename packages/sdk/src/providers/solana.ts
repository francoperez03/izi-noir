/**
 * Solana on-chain verification provider for IZI-NOIR.
 *
 * This module provides functionality to verify Groth16 proofs on-chain using
 * the IZI-NOIR Solana program. It's compatible with proofs generated by the
 * Arkworks provider.
 *
 * @example Basic usage
 * ```typescript
 * import { SolanaVerifier } from '@izi-noir/sdk/solana';
 * import { Connection, Keypair } from '@solana/web3.js';
 *
 * const connection = new Connection('https://api.devnet.solana.com');
 * const wallet = Keypair.generate(); // In practice, use a real wallet
 *
 * const verifier = new SolanaVerifier({
 *   connection,
 *   wallet,
 *   programId: 'EYhRED7EuMyyVjx57aDXUD9h6ArnEKng64qtz8999KrS',
 * });
 *
 * // Initialize a VK account from base64-encoded VK
 * const vkAccount = await verifier.initVkFromBase64(vkGnarkBase64, nrPubinputs);
 *
 * // Verify a proof on-chain
 * const txSig = await verifier.verifyProof(
 *   vkAccount,
 *   proofGnarkBase64,
 *   publicInputsHex
 * );
 * ```
 *
 * @module @izi-noir/sdk/solana
 */

// Constants matching the Solana program
export const G1_SIZE = 64;
export const G2_SIZE = 128;
export const FIELD_SIZE = 32;
export const PROOF_SIZE = 256;
export const MAX_PUBLIC_INPUTS = 16;

// Program ID - deployed on devnet
export const IZI_NOIR_PROGRAM_ID = 'EYhRED7EuMyyVjx57aDXUD9h6ArnEKng64qtz8999KrS';

/**
 * Configuration for the SolanaVerifier.
 */
export interface SolanaVerifierConfig {
  /**
   * Solana RPC connection.
   * Must be compatible with @solana/web3.js Connection.
   */
  connection: unknown;

  /**
   * Wallet for signing transactions.
   * Can be a Keypair or any wallet adapter compatible signer.
   */
  wallet: unknown;

  /**
   * Program ID of the deployed IZI-NOIR verifier program.
   * Defaults to the placeholder ID.
   */
  programId?: string;
}

/**
 * Result from initializing a VK account.
 */
export interface InitVkResult {
  /** The public key of the created VK account */
  vkAccount: string;
  /** The transaction signature */
  txSignature: string;
}

/**
 * Result from verifying a proof on-chain.
 */
export interface VerifyResult {
  /** Whether the proof was verified successfully */
  success: boolean;
  /** The transaction signature */
  txSignature: string;
  /** Error message if verification failed */
  error?: string;
}

/**
 * Parses a base64-encoded verifying key into its components.
 *
 * The VK format from arkworks gnark_compat is:
 * | alpha_g1 (64) | beta_g2 (128) | gamma_g2 (128) | delta_g2 (128) | k[0..n+1] (64 each) |
 *
 * @param vkBase64 - Base64-encoded verifying key
 * @param nrPubinputs - Number of public inputs
 * @returns Parsed VK components
 */
export function parseVerifyingKey(vkBase64: string, nrPubinputs: number): {
  alphaG1: Uint8Array;
  betaG2: Uint8Array;
  gammaG2: Uint8Array;
  deltaG2: Uint8Array;
  k: Uint8Array[];
} {
  const vkBytes = base64ToBytes(vkBase64);
  const expectedLen = G1_SIZE + G2_SIZE * 3 + G1_SIZE * (nrPubinputs + 1);

  if (vkBytes.length !== expectedLen) {
    throw new Error(
      `Invalid VK size: expected ${expectedLen} bytes for ${nrPubinputs} public inputs, got ${vkBytes.length}`
    );
  }

  let offset = 0;

  const alphaG1 = vkBytes.slice(offset, offset + G1_SIZE);
  offset += G1_SIZE;

  const betaG2 = vkBytes.slice(offset, offset + G2_SIZE);
  offset += G2_SIZE;

  const gammaG2 = vkBytes.slice(offset, offset + G2_SIZE);
  offset += G2_SIZE;

  const deltaG2 = vkBytes.slice(offset, offset + G2_SIZE);
  offset += G2_SIZE;

  const k: Uint8Array[] = [];
  for (let i = 0; i <= nrPubinputs; i++) {
    k.push(vkBytes.slice(offset, offset + G1_SIZE));
    offset += G1_SIZE;
  }

  return { alphaG1, betaG2, gammaG2, deltaG2, k };
}

/**
 * Parses a base64-encoded proof into its components.
 *
 * The proof format is: A (G1, 64) || B (G2, 128) || C (G1, 64) = 256 bytes
 *
 * @param proofBase64 - Base64-encoded proof
 * @returns Parsed proof components
 */
export function parseProof(proofBase64: string): {
  a: Uint8Array;
  b: Uint8Array;
  c: Uint8Array;
} {
  const proofBytes = base64ToBytes(proofBase64);

  if (proofBytes.length !== PROOF_SIZE) {
    throw new Error(`Invalid proof size: expected ${PROOF_SIZE} bytes, got ${proofBytes.length}`);
  }

  return {
    a: proofBytes.slice(0, G1_SIZE),
    b: proofBytes.slice(G1_SIZE, G1_SIZE + G2_SIZE),
    c: proofBytes.slice(G1_SIZE + G2_SIZE, PROOF_SIZE),
  };
}

/**
 * Parses public inputs from hex or decimal string format to 32-byte arrays.
 *
 * @param inputs - Array of public inputs as hex (0x...) or decimal strings
 * @returns Array of 32-byte big-endian field elements
 */
export function parsePublicInputs(inputs: string[]): Uint8Array[] {
  return inputs.map((input) => {
    // Handle hex strings
    if (input.startsWith('0x')) {
      const hex = input.slice(2).padStart(64, '0');
      return hexToBytes(hex);
    }

    // Handle decimal strings - convert to big-endian bytes
    const num = BigInt(input);
    const hex = num.toString(16).padStart(64, '0');
    return hexToBytes(hex);
  });
}

/**
 * Calculates the size of a VK account for a given number of public inputs.
 *
 * This matches the Rust `vk_account_size` function.
 *
 * @param nrPubinputs - Number of public inputs
 * @returns Account size in bytes
 */
export function calculateVkAccountSize(nrPubinputs: number): number {
  // discriminator (8) + authority (32) + nr_pubinputs (1) + alpha_g1 (64) +
  // beta_g2 (128) + gamma_g2 (128) + delta_g2 (128) + vec_len (4) + k elements
  const fixedSize = 8 + 32 + 1 + G1_SIZE + G2_SIZE * 3 + 4;
  return fixedSize + (nrPubinputs + 1) * G1_SIZE;
}

/**
 * Calculates the minimum rent for a VK account.
 *
 * @param nrPubinputs - Number of public inputs
 * @param rentExemptionPerByte - Rent per byte (default Solana rate)
 * @returns Rent in lamports
 */
export function calculateVkAccountRent(
  nrPubinputs: number,
  rentExemptionPerByte: number = 6960 // approximate lamports per byte
): number {
  const size = calculateVkAccountSize(nrPubinputs);
  return size * rentExemptionPerByte;
}

// ========== Helper Functions ==========

/**
 * Converts a base64 string to a Uint8Array.
 */
function base64ToBytes(base64: string): Uint8Array {
  // Browser-compatible base64 decoding
  if (typeof atob === 'function') {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  // Node.js fallback
  return new Uint8Array(Buffer.from(base64, 'base64'));
}

/**
 * Converts a Uint8Array to a base64 string.
 */
export function bytesToBase64(bytes: Uint8Array): string {
  // Browser-compatible base64 encoding
  if (typeof btoa === 'function') {
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  // Node.js fallback
  return Buffer.from(bytes).toString('base64');
}

/**
 * Converts a hex string to Uint8Array.
 */
function hexToBytes(hex: string): Uint8Array {
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(cleanHex.substring(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

/**
 * Converts a Uint8Array to hex string.
 */
export function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

// ========== Instruction Data Builders ==========

/**
 * Builds the instruction data for `init_vk_from_bytes`.
 *
 * Note: This is a simplified version. In practice, you'd use Anchor's IDL
 * and instruction builders from the generated types.
 *
 * @param nrPubinputs - Number of public inputs
 * @param vkBytes - Raw VK bytes
 * @returns Instruction data
 */
export function buildInitVkFromBytesData(nrPubinputs: number, vkBytes: Uint8Array): Uint8Array {
  // Anchor instruction discriminator for "init_vk_from_bytes"
  // From IDL: [103, 78, 249, 70, 245, 176, 87, 56]
  const discriminator = new Uint8Array([103, 78, 249, 70, 245, 176, 87, 56]);

  // Build instruction data: discriminator + nr_pubinputs (u8) + vk_bytes (Vec<u8>)
  const vkLen = new Uint8Array(4);
  new DataView(vkLen.buffer).setUint32(0, vkBytes.length, true); // little-endian

  const data = new Uint8Array(discriminator.length + 1 + 4 + vkBytes.length);
  let offset = 0;

  data.set(discriminator, offset);
  offset += discriminator.length;

  data[offset] = nrPubinputs;
  offset += 1;

  data.set(vkLen, offset);
  offset += 4;

  data.set(vkBytes, offset);

  return data;
}

/**
 * Builds the instruction data for `verify_proof`.
 *
 * @param proofBytes - 256-byte proof
 * @param publicInputs - Array of 32-byte field elements
 * @returns Instruction data
 */
export function buildVerifyProofData(
  proofBytes: Uint8Array,
  publicInputs: Uint8Array[]
): Uint8Array {
  // Anchor instruction discriminator for "verify_proof"
  // From IDL: [217, 211, 191, 110, 144, 13, 186, 98]
  const discriminator = new Uint8Array([217, 211, 191, 110, 144, 13, 186, 98]);

  // Validate proof size
  if (proofBytes.length !== PROOF_SIZE) {
    throw new Error(`Invalid proof size: expected ${PROOF_SIZE}, got ${proofBytes.length}`);
  }

  // Calculate total size
  const proofVecLen = 4 + proofBytes.length;
  const inputsVecLen = 4 + publicInputs.length * FIELD_SIZE;
  const totalSize = discriminator.length + proofVecLen + inputsVecLen;

  const data = new Uint8Array(totalSize);
  let offset = 0;

  // Discriminator
  data.set(discriminator, offset);
  offset += discriminator.length;

  // proof_bytes as Vec<u8>
  new DataView(data.buffer).setUint32(offset, proofBytes.length, true);
  offset += 4;
  data.set(proofBytes, offset);
  offset += proofBytes.length;

  // public_inputs as Vec<[u8; 32]>
  new DataView(data.buffer).setUint32(offset, publicInputs.length, true);
  offset += 4;
  for (const input of publicInputs) {
    if (input.length !== FIELD_SIZE) {
      throw new Error(`Invalid public input size: expected ${FIELD_SIZE}, got ${input.length}`);
    }
    data.set(input, offset);
    offset += FIELD_SIZE;
  }

  return data;
}

/**
 * Type definition for the Anchor IDL accounts structure.
 * This helps with type safety when building transactions.
 */
export interface IziNoirAccounts {
  initVk: {
    vkAccount: string;
    authority: string;
    payer: string;
    systemProgram: string;
  };
  verifyProof: {
    vkAccount: string;
  };
  closeVk: {
    vkAccount: string;
    authority: string;
  };
}

/**
 * Placeholder class for SolanaVerifier.
 *
 * This class provides the interface for on-chain verification but requires
 * @solana/web3.js and @coral-xyz/anchor to be installed as peer dependencies.
 *
 * For full functionality, install the required dependencies:
 * ```bash
 * npm install @solana/web3.js @coral-xyz/anchor
 * ```
 *
 * Then use the generated Anchor client from the solana-contracts package.
 */
export class SolanaVerifier {
  private config: SolanaVerifierConfig;

  constructor(config: SolanaVerifierConfig) {
    this.config = config;
  }

  /**
   * Initializes a VK account from base64-encoded verifying key.
   *
   * Note: This is a placeholder. Use the generated Anchor client for
   * actual transaction building and submission.
   */
  async initVkFromBase64(vkBase64: string, nrPubinputs: number): Promise<InitVkResult> {
    // Parse and validate VK
    const vkBytes = base64ToBytes(vkBase64);
    const expectedLen = G1_SIZE + G2_SIZE * 3 + G1_SIZE * (nrPubinputs + 1);

    if (vkBytes.length !== expectedLen) {
      throw new Error(
        `Invalid VK size: expected ${expectedLen} bytes for ${nrPubinputs} public inputs, got ${vkBytes.length}`
      );
    }

    // This is a placeholder - actual implementation would use Anchor client
    throw new Error(
      'SolanaVerifier.initVkFromBase64 requires @solana/web3.js and @coral-xyz/anchor. ' +
        'Use the generated Anchor client from solana-contracts package.'
    );
  }

  /**
   * Verifies a proof on-chain.
   *
   * Note: This is a placeholder. Use the generated Anchor client for
   * actual transaction building and submission.
   */
  async verifyProof(
    vkAccount: string,
    proofBase64: string,
    publicInputs: string[]
  ): Promise<VerifyResult> {
    // Parse and validate proof
    const proofBytes = base64ToBytes(proofBase64);
    if (proofBytes.length !== PROOF_SIZE) {
      throw new Error(`Invalid proof size: expected ${PROOF_SIZE}, got ${proofBytes.length}`);
    }

    // This is a placeholder - actual implementation would use Anchor client
    throw new Error(
      'SolanaVerifier.verifyProof requires @solana/web3.js and @coral-xyz/anchor. ' +
        'Use the generated Anchor client from solana-contracts package.'
    );
  }

  /**
   * Closes a VK account and reclaims rent.
   *
   * Note: This is a placeholder. Use the generated Anchor client for
   * actual transaction building and submission.
   */
  async closeVk(vkAccount: string): Promise<string> {
    throw new Error(
      'SolanaVerifier.closeVk requires @solana/web3.js and @coral-xyz/anchor. ' +
        'Use the generated Anchor client from solana-contracts package.'
    );
  }
}

// Re-export common types
export type { CompiledCircuit, InputMap, ProofData } from '../domain/types.js';
