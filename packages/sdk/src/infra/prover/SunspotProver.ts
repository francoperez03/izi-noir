import { writeFile, readFile, rm } from 'node:fs/promises';
import type { IProver } from '../../domain/interfaces/IProver.js';
import type { CompiledCircuit, InputMap, ProofData } from '../../domain/types.js';
import type { SunspotConfig, SunspotCompiledCircuit } from '../sunspot/types.js';
import { DEFAULT_SUNSPOT_CONFIG, isSunspotCircuit, SunspotCliError } from '../sunspot/types.js';
import { SunspotCliExecutor } from '../sunspot/SunspotCliExecutor.js';

/**
 * Generates and verifies Groth16 proofs using Sunspot CLI.
 * Produces proofs compatible with Solana on-chain verification.
 */
export class SunspotProver implements IProver {
  private readonly config: SunspotConfig;
  private readonly executor: SunspotCliExecutor;

  constructor(config: Partial<SunspotConfig> = {}) {
    this.config = { ...DEFAULT_SUNSPOT_CONFIG, ...config };
    this.executor = new SunspotCliExecutor(this.config);
  }

  async generateProof(circuit: CompiledCircuit, inputs: InputMap): Promise<ProofData> {
    if (!isSunspotCircuit(circuit)) {
      throw new Error(
        'SunspotProver requires a SunspotCompiledCircuit. Use SunspotCompiler to compile the circuit.'
      );
    }

    const paths = circuit.paths;

    try {
      // 1. Write Prover.toml with inputs
      const proverToml = this.generateProverToml(inputs);
      await writeFile(paths.proverTomlPath, proverToml);

      // 2. Run nargo execute to generate witness
      await this.executor.nargoExecute(paths.noirProjectDir);

      // 3. Run sunspot prove to generate proof
      await this.executor.sunspotProve(
        paths.circuitJsonPath,
        paths.witnessPath,
        paths.ccsPath,
        paths.pkPath
      );

      // 4. Read proof and public witness files
      const proofBytes = new Uint8Array(await readFile(paths.proofPath));
      const publicWitnessBytes = new Uint8Array(await readFile(paths.publicWitnessPath));

      // 5. Parse public inputs from public witness
      const publicInputs = this.parsePublicWitness(publicWitnessBytes);

      return {
        proof: proofBytes,
        publicInputs,
      };
    } catch (error) {
      // Cleanup on error if not keeping artifacts
      if (!this.config.keepArtifacts) {
        await rm(paths.workDir, { recursive: true, force: true }).catch(() => {});
      }
      throw error;
    }
    // Note: We don't cleanup here - verifyProof will handle cleanup after verification
  }

  async verifyProof(
    circuit: CompiledCircuit,
    proof: Uint8Array,
    publicInputs: string[]
  ): Promise<boolean> {
    if (!isSunspotCircuit(circuit)) {
      throw new Error(
        'SunspotProver requires a SunspotCompiledCircuit. Use SunspotCompiler to compile the circuit.'
      );
    }

    const paths = circuit.paths;

    try {
      // Note: We use the existing .proof and .pw files generated by sunspot prove
      // They should already be in place from the generateProof call
      // Only write if the proof bytes don't match (e.g., verifying a different proof)
      const existingProof = await readFile(paths.proofPath).catch(() => null);
      if (!existingProof || !this.bytesEqual(existingProof, proof)) {
        await writeFile(paths.proofPath, proof);
        // If proof changed, we need to regenerate pw file - not supported in this flow
        // For now, assume we're verifying the proof we just generated
      }

      // Run sunspot verify using the existing files
      await this.executor.sunspotVerify(
        paths.vkPath,
        paths.proofPath,
        paths.publicWitnessPath
      );

      return true;
    } catch (error) {
      // Verification failed
      if (error instanceof SunspotCliError) {
        // Check if it's a verification failure vs other error
        if (error.stderr.toLowerCase().includes('verification failed') ||
            error.stderr.toLowerCase().includes('invalid proof')) {
          return false;
        }
      }
      throw error;
    } finally {
      // Cleanup temp files after verification
      if (!this.config.keepArtifacts) {
        await rm(paths.workDir, { recursive: true, force: true }).catch(() => {});
      }
    }
  }

  /**
   * Generate Prover.toml content from InputMap
   */
  private generateProverToml(inputs: InputMap): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(inputs)) {
      const formattedValue = this.formatTomlValue(value);
      lines.push(`${key} = ${formattedValue}`);
    }

    return lines.join('\n') + '\n';
  }

  /**
   * Format a value for TOML
   */
  private formatTomlValue(value: unknown): string {
    if (typeof value === 'string') {
      // Hex strings or regular strings
      if (value.startsWith('0x')) {
        return `"${value}"`;
      }
      // Check if it's a number-like string
      if (/^\d+$/.test(value)) {
        return value;
      }
      return `"${value}"`;
    }
    if (typeof value === 'number') {
      return value.toString();
    }
    if (typeof value === 'bigint') {
      return value.toString();
    }
    if (Array.isArray(value)) {
      const items = value.map(v => this.formatTomlValue(v));
      return `[${items.join(', ')}]`;
    }
    return String(value);
  }

  /**
   * Parse public witness binary file to string array
   * Format: Series of 32-byte BN254 field elements
   */
  private parsePublicWitness(bytes: Uint8Array): string[] {
    const publicInputs: string[] = [];
    const FIELD_SIZE = 32;

    for (let i = 0; i < bytes.length; i += FIELD_SIZE) {
      const fieldBytes = bytes.slice(i, Math.min(i + FIELD_SIZE, bytes.length));
      if (fieldBytes.length === FIELD_SIZE) {
        const hex = '0x' + Array.from(fieldBytes)
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        publicInputs.push(hex);
      }
    }

    return publicInputs;
  }

  /**
   * Encode public inputs back to binary format
   */
  private encodePublicWitness(publicInputs: string[]): Uint8Array {
    const FIELD_SIZE = 32;
    const buffer = new Uint8Array(publicInputs.length * FIELD_SIZE);

    for (let i = 0; i < publicInputs.length; i++) {
      const value = publicInputs[i];
      const bytes = this.hexToBytes(value, FIELD_SIZE);
      buffer.set(bytes, i * FIELD_SIZE);
    }

    return buffer;
  }

  /**
   * Convert hex string to bytes with padding
   */
  private hexToBytes(hex: string, length: number): Uint8Array {
    const normalized = hex.startsWith('0x') ? hex.slice(2) : hex;
    const padded = normalized.padStart(length * 2, '0');
    const bytes = new Uint8Array(length);

    for (let i = 0; i < length; i++) {
      bytes[i] = parseInt(padded.slice(i * 2, i * 2 + 2), 16);
    }

    return bytes;
  }

  /**
   * Compare two byte arrays for equality
   */
  private bytesEqual(a: Buffer | Uint8Array, b: Uint8Array): boolean {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
}
